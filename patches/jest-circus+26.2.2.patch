diff --git a/node_modules/jest-circus/build/legacy-code-todo-rewrite/jestAdapterInit.d.ts b/node_modules/jest-circus/build/legacy-code-todo-rewrite/jestAdapterInit.d.ts
index fb07695..687d34e 100644
--- a/node_modules/jest-circus/build/legacy-code-todo-rewrite/jestAdapterInit.d.ts
+++ b/node_modules/jest-circus/build/legacy-code-todo-rewrite/jestAdapterInit.d.ts
@@ -49,3 +49,54 @@ export declare const runAndTransformResultsToJestFormat: ({ config, globalConfig
     testPath: string;
 }) => Promise<TestResult>;
 export {};
+/**
+ * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
+ *
+ * This source code is licensed under the MIT license found in the
+ * LICENSE file in the root directory of this source tree.
+ */
+/// <reference types="node" />
+import type { Config, Global } from '@jest/types';
+import type { JestEnvironment } from '@jest/environment';
+import { TestResult } from '@jest/test-result';
+import type { TestFileEvent } from 'jest-runner';
+declare type Process = NodeJS.Process;
+export declare const initialize: ({ config, environment, getPrettier, getBabelTraverse, globalConfig, localRequire, parentProcess, testPath, sendMessageToJest, }: {
+    config: Config.ProjectConfig;
+    environment: JestEnvironment;
+    getPrettier: () => null | any;
+    getBabelTraverse: () => Function;
+    globalConfig: Config.GlobalConfig;
+    localRequire: (path: Config.Path) => any;
+    testPath: Config.Path;
+    parentProcess: Process;
+    sendMessageToJest?: import("jest-runner/build/types").TestFileEvent<"test-file-start" | "test-file-success" | "test-file-failure" | "test-case-result"> | undefined;
+}) => Promise<{
+    globals: {
+        afterAll: (fn: Global.TestFn, timeout?: number | undefined) => void;
+        afterEach: (fn: Global.TestFn, timeout?: number | undefined) => void;
+        beforeAll: (fn: Global.TestFn, timeout?: number | undefined) => void;
+        beforeEach: (fn: Global.TestFn, timeout?: number | undefined) => void;
+        describe: {
+            (blockName: string, blockFn: Global.BlockFn): void;
+            each: (table: Global.EachTable, ...taggedTemplateData: Global.TemplateData) => (title: string, test: Global.EachTestFn, timeout?: number | undefined) => void;
+            only: {
+                (blockName: string, blockFn: Global.BlockFn): void;
+                each: (table: Global.EachTable, ...taggedTemplateData: Global.TemplateData) => (title: string, test: Global.EachTestFn, timeout?: number | undefined) => void;
+            };
+            skip: {
+                (blockName: string, blockFn: Global.BlockFn): void;
+                each: (table: Global.EachTable, ...taggedTemplateData: Global.TemplateData) => (title: string, test: Global.EachTestFn, timeout?: number | undefined) => void;
+            };
+        };
+        it: Global.It;
+        test: Global.It;
+    };
+    snapshotState: import("jest-snapshot/build/State").default;
+}>;
+export declare const runAndTransformResultsToJestFormat: ({ config, globalConfig, testPath, }: {
+    config: Config.ProjectConfig;
+    globalConfig: Config.GlobalConfig;
+    testPath: string;
+}) => Promise<TestResult>;
+export {};
diff --git a/node_modules/jest-circus/build/legacy-code-todo-rewrite/jestAdapterInit.js b/node_modules/jest-circus/build/legacy-code-todo-rewrite/jestAdapterInit.js
index f98a006..36106de 100644
--- a/node_modules/jest-circus/build/legacy-code-todo-rewrite/jestAdapterInit.js
+++ b/node_modules/jest-circus/build/legacy-code-todo-rewrite/jestAdapterInit.js
@@ -50,6 +50,8 @@ const initialize = async ({
   testPath,
   sendMessageToJest
 }) => {
+  var _config$testNamePatte;
+
   if (globalConfig.testTimeout) {
     (0, _state.getState)().testTimeout = globalConfig.testTimeout;
   }
@@ -66,7 +68,7 @@ const initialize = async ({
   nodeGlobal.test.concurrent = (test => {
     const concurrent = (testName, testFn, timeout) => {
       // For concurrent tests we first run the function that returns promise, and then register a
-      // nomral test that will be waiting on the returned promise (when we start the test, the promise
+      // normal test that will be waiting on the returned promise (when we start the test, the promise
       // will already be in the process of execution).
       // Unfortunately at this stage there's no way to know if there are any `.only` tests in the suite
       // that will result in this test to be skipped, so we'll be executing the promise function anyway,
@@ -94,7 +96,11 @@ const initialize = async ({
   await (0, _state.dispatch)({
     name: 'setup',
     parentProcess,
-    testNamePattern: globalConfig.testNamePattern
+    testNamePattern:
+      (_config$testNamePatte = config.testNamePattern) !== null &&
+      _config$testNamePatte !== void 0
+        ? _config$testNamePatte
+        : globalConfig.testNamePattern
   });
 
   if (config.testLocationInResults) {
@@ -173,6 +179,7 @@ const runAndTransformResultsToJestFormat = async ({
     return {
       ancestorTitles,
       duration: testResult.duration,
+      failureDetails: testResult.errorsDetailed,
       failureMessages: testResult.errors,
       fullName: title
         ? ancestorTitles.concat(title).join(' ')
